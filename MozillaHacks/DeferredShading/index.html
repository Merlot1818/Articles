<html>
<head>
<title>WebGL Deferred Shading</title>
</head>
<body>
<link rel="stylesheet" href="index.css" type="text/css" />
<div id = "content-main">
<h2>WebGL Deferred Shading</h2>
<p class="authors"><span>by</span> Sijie Tian, Yuqin Shao, Patrick Cozzi</p>

<p>
WebGL brings hardware-accelerated 3D graphics to the web.  The next version, <a href="https://wiki.mozilla.org/Platform/GFX/WebGL2" target="_blank">WebGL 2</a>, is a work-in-progress, but many features are available today as WebGL extensions.  In this article, we describe how to use the <a href="http://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers/">WEBGL_draw_buffers</a> extension to create a scene with a large number of dynamic lights using a technique called deferred shading, which is popular among AAA games.
</p>
<p>
<img src="DeferredShadingPic1.png" />
</p>
<p>
<a href="http://sijietian.com/WebGL/deferredshading/index.html">demo</a> &bullet;
<a href="https://github.com/YuqinShao/Tile_Based_WebGL_DeferredShader">source</a> &bullet;
<a href="https://vimeo.com/82070755">video</a>
</p>
<p>
Today, most WebGL engines use forward shading, where lighting is computed in the same pass that geometry is transformed.  This makes it difficult to support a large number of dynamic lights and different light types.
</p>
<p>
Some forward shaders use a pass per light.  Rendering a scene looks like:
</p>
<pre>
foreach light {
  foreach visible mesh {
    if (light volume intersects mesh) {
      render using shader for this material/light;
      accumulate in framebuffer using blending;
    }
  }
}
</pre>
<p>
This requires a different shader for each material/light-type combination, which can add up.  From a performance perspective, each mesh needs to be rendered (vertex transform, rasterization, material part of the fragment shader, etc.) once per light instead of just once, and occluded fragments are still shaded unless front-to-back sorting or a z-prepass is used.  In addition, even if a light's volume intersects a mesh, it may only affect a small part of the mesh, but the entire mesh is still rendered.
</p>
<p>
Forward shaders can also use a single pass making rendering a scene look like:
</p>
<pre>
foreach visible mesh {
  find lights affecting mesh;
  Render all lights and materials using a single shader;
}
</pre>
<p>
Although meshes are only rendered once, this has the same performance drawbacks for occluded fragments.  The biggest drawback is the number of shaders required since a different shader is required for each material/light (not light type) combination.  This makes shaders harder to author, increases compile times, usually requires runtime compiling, and increases the number of shaders to sort by.
</p>
<h2>Deferred Shading</h2>
Deferred shading takes a different approach than forward shading by dividing rendering into two passes: one that transforms the geometry and writes positions, normals, and material properties to textures called g-buffers and another that performs lighting as a series of screen-space post-processing effects.
<pre>
foreach visible mesh {
  write material properties to g-buffer;
}

foreach light {
  compute light by reading g-buffer;
  accumulate in framebuffer;
}
</pre>
<p>
This decouples lighting from scene complexity only requiring one shader per material and one shader per light type.  Since lighting takes place in screen-space, occluded fragments are not shaded, essentially bringing the depth complexity down to one for lighting.
</p>
<p>
Until recently, WebGL had a roadblock for implementing different shading.  In WebGL, a fragment shader could only write to a single texture/renderbuffer.  With deferred shading, the g-buffer is usually composed of several textures.  This means that the geometry needed to be rendered multiple times.
</p>
<p>
Now with the WEBGL_draw_buffers extension, a fragment shader can write to several textures making deferred shading possible in WebGL.  To use this extension in Firefox, browse to about:config and turn on webgl.enable-draft-extensions.  Then, to make sure your system supports WEBGL_draw_buffers, browse to <a href="http://webglreport.com/">webglreport.com</a> and verify that it is in the list of extensions at the bottom of the page.
</p>
<img src="DeferredShadingPic2.png"/>
<p>
To use the extension, first initialize it:
</p>
<pre lang="javascript">
var ext = gl.getExtension("WEBGL_draw_buffers");
if (!ext) {
  // ...
}
</pre>
<p>
Now we can bind different texture units to framebuffer slots:
</p>
<pre lang="javascript">
var buffers = [];
buffers[0] = ext.COLOR_ATTACHMENT0_WEBGL;
buffers[1] = ext.COLOR_ATTACHMENT1_WEBGL;
buffers[2] = ext.COLOR_ATTACHMENT2_WEBGL;
buffers[3] = ext.COLOR_ATTACHMENT3_WEBGL;
ext.drawBuffersWEBGL(buffers);
</pre>
<p>
In the geometry pass, the fragment shader writes to the textures.  A trivial pass-through fragment shader for testing would be:
</p>
<pre>
#extension GL_EXT_draw_buffers : require
precision highp float;
void main(void) {
  gl_FragData[0] = vec4(1.0);
  gl_FragData[1] = vec4(1.0);
  gl_FragData[2] = vec4(1.0);
  gl_FragData[3] = vec4(1.0);
}
</pre>
<p>
Even though we initialized the extension in JavaScript with <span>gl.getExtension</span>, the GLSL code still needs to include <span>#extension GL_EXT_draw_buffers : require</span> to use the extension.  Without the extension, fragment shaders write to <span>gl_FragColor</span>; with the extension, fragment shaders now have access to <span>gl_FragData</span>, which is an array.
</p>
<p>
  In our project, we have four different textures/buffers, respectively are depth buffer, normal buffer, position buffer and color buffer. Besides depth buffer uses unsigned short DEPTH_COMPONENT, other textures/buffers are using floating point RGBA format.
</p>
<p>
Depth Rendering
<img src="depth.png"/>
</p>
<p>
Normal Rendering
<img src="normal.png"/>
</p>
<p>
Position Rendering
<img src="position.png"/>
</p>
<p>
Color and Ambient Rending
<img src="color+ambient.png"/>
</p>
<p>
G-Buffers Layout
<img src="layout.png"/>
</p>

<p>
The extension allows a single geometry pass to write to all the g-buffers, which improves performance and reduces the amount of JavaScript code. The difference between these two methods becomes bigger as scene complexity increses. Performance numbers using FireFox 25.0.1 and an NVIDIA GT 620M on Window 8 are shown below.
</p>
<p>
<img src="DeferredShadingPic6.png"/>
</p>
<p>
Screen shot of draw buffer extension test on WebGL using <a href = "http://www.d.umn.edu/~ddunham/cs5721f07/schedule/resources/models/dragon.obj">Stanford Dragon </a>.
</p>
<p>
<img src="DeferredShadingPic7.png"/>
</p>
<p>
Deferred shading requires a lot of GPU memory bandwidth, which is not ideal for performance or power.  In a naive implementation, each light is rendered as a full-screen quad and reads the entirety of each g-buffer.  Since most light types, like point and spot lights, attenuate and have an area of influence, the full-screen quad can be replaced with a world-space (or other object coordinate space) bounding volume or tight screen-space bounding rectangle.
</p>
<h2>Tile-Based Deferred Shading</h2>
<p>
Tile-based deferred shading takes this a step farther and splits the screen into tiles, for example 16x16 pixels, and then determines which lights influence each tile.  Light-tile information is then passed to the shader and the g-buffer is only read once for all lights. Since this drastically reduces memory bandwidth, it improves performance.  The following image contains 200 lights on a 800x600 screen with 16x16 tile size.
<p>
<p>
<img src="DeferredShadingPic5.png"/>
</p>
<p>
  The size of tile affects the performance. Small tile means more computation on lighting construction and storage on light-tile information, but less computation on lighting in shader. The big tile is the opposite. Therefore, choosing a suitable tile is important for the performance. The figure below is shown the relationship between tile size and performance.
</p>
<p>
<img src="DeferredShadingPic8.png"/>
</p>
<p>
Tile debug visualization is shown below. Each tile indicates the density of lights. More lights in a tile are more close to white.
</p>
<p>
<img src="TileDebugView.png"/>
</p>
<p>
<img src="TileView.png"/>
</p>

<h2>Acknowledgements</h2>
<p>
We implemented this project for the course <a href="http://www.seas.upenn.edu/~cis565/" target="_blank">CIS 565: GPU Programming and Architecture</a>, which is part of the <a href="http://cg.cis.upenn.edu/" target="_blank">computer graphics program</a> at the University of Pennsylvania.  We thank <a href="http://liamboone.blogspot.com/" target="_blank">Liam Boone</a> for his support and <a href="http://erich.realtimerendering.com/" target="_blank">Eric Haines</a> for reviewing this article.
</p>
<h2>References</h2>
<p>

<ul>
  <li>Our source code is on <a href="https://github.com/YuqinShao/Tile_Based_WebGL_DeferredShader" target="_blank">github</a></li>
  <li><a href="http://graphics.cs.williams.edu/data/meshes.xml" target="_blank">Models</a>  we are using</li>
  <li><a href="http://www.guerrilla-games.com/publications/dr_kz2_rsx_dev07.pdf" target="_blank">Deferred Rendering in Killzone 2</a>. Michal Valient</li>
  <li><a href="http://www.slideshare.net/cagetu/light-prepass" target="_blank">Light Pre-Pass</a>. Wolfgang Engel</li>
  <li><a href="http://aras-p.info/texts/CompactNormalStorage.html" target="_blank">Compact Normal Storage for Small 
G-Buffers</a>. Aras Pranckevicius</li>
  <li><a href="http://www.cse.chalmers.se/~uffe/tiled_shading_preprint.pdf" target="_blank">Tiled Shading</a>. Ola Olsson and Ulf Assarsson</li>
  <li><a href="http://bps10.idav.ucdavis.edu/talks/12-lauritzen_DeferredShading_BPS_SIGGRAPH2010_Notes.pdf" target="_blank">Deferred Rendering for Current and Future Rendering Pipelines</a>. Andrew Lauritzen</li>

</ul>
</p>

<!--
// TODO: MRT vs. multiple geometry passes with increasing scene complexity
// TODO: Tile size performance graph
// TODO: g-buffers, g-buffer layout, and tile debug figures
// TODO: Reference for tile-based
// TODO: Firefox version and OS for performance numbers
// TODO: embed video?

// Patrick TODO: bind textures when calling drawBuffersWEBGL
// Patrick TODO: max gl_FragData[] length?
// Patrick TODO: drawbacks of deferred shading
-->

</body>
</html>