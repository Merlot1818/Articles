<html>
<head>
</head>
<body>
<h1>Why use WebGL for Graphics Research?</h1>
<p>
By Patrick Cozzi, <a href="https://twitter.com/pjcozzi" target="_blank">@pjcozzi</a>.
</p>

<p>
I think WebGL will become the graphics API of choice for real-time graphics research.  Here's why.
</p>

<p>
<strong>An interactive demo is better than a video</strong>.
</p>
<p>
WebGL allows us to embed our demo on a website, like the <a href="http://jcgt.org/published/0001/01/02/webdemo/index.html" target="_blank">demo</a> for <a href="http://jcgt.org/published/0001/01/02/" target="_blank">The Compact YCoCg Frame Buffer</a> by Pavlos Mavridis and Georgios Papaioannou.  A demo gives readers a better understanding than a video alone and can allow readers to reproduce performance results on their hardware and debug views like the <a href="http://sijietian.com/WebGL/deferredshading/index.html" target="_blank">demo</a> for <a href="https://hacks.mozilla.org/2014/01/webgl-deferred-shading/" target="_blank">WebGL Deferred Shading</a> by Sijie Tian, Yuqin Shao, and I.  This is, of course, true for a demo written with any graphics API, but WebGL makes the barrier to entry very low; only requiring clicking on a link.  Readers and reviewers are much more likely to check it out.
</p>

<p>
<strong>WebGL runs on desktop and mobile</strong>.
</p>
<p>
Android devices now have pretty good support for WebGL (iOS still only enables WebGL for iAds).  This allows us to write the majority of our demo once and get performance numbers for both desktop and mobile.  This is especially useful for algorithms that will have different performance implications due to the differences in GPU architectures, e.g., early-z vs. tile-based, or network bandwidth, e.g., streaming massive models.
</p>

<p>
<strong>WebGL is starting to expose modern GPU features</strong>.
</p>
<p>
WebGL is based on OpenGL ES 2.0 so it doesn't expose features like query timers, compute shaders, uniform buffers, etc., or even instancing or multiple render targets.  However, with some <a href="https://wiki.mozilla.org/Platform/GFX/WebGL2" target="_blank">WebGL 2</a> (based on ES 3.0) features being exposed as extensions, we are getting access to more GPU features.  Given that OpenGL ES Next will be <a href="http://www.khronos.org/assets/uploads/news/news_graphics/OpenGL-ES-Next-Jan14.pdf" target="_blank">released this year</a> with compute shaders, atomics, and image load/store, we can expect WebGL to follow.  This will allow compute-shader-based research in WebGL, an area where I expect we'll continue to see innovation.  In addition, with NVIDIA Tegra K1 (Logan), we will see <a href="http://blogs.nvidia.com/blog/2013/07/24/kepler-to-mobile/" target="_blank">OpenGL 4.4 support on mobile</a>, which could ultimately mean more features exposed by WebGL to keep pace with mobile.
</p>
<p>
Some graphics research areas, like animation, don't always need access to the latest GPU features and instead just need a way to visualization their results.  Even many of the latest <a href="http://jcgt.org/read.html?reload=1" target="_blank">JCGT</a> papers on rendering can be implemented with WebGL and the extensions it exposes today.  Some research will always need to explore the latest GPU features, but my claim is that WebGL has a bright future here and is already capable for a lot of research.
</p>

<p>
<strong>WebGL is faster to develop with</strong>.
</p>
<p>
Coming from C++, JavaScript does take some getting use to (see <a href="http://casual-effects.blogspot.com/2014/01/an-introduction-to-javascript-for.html" target="_blank">An Introduction to JavaScript for Sophisticated Programmers</a> by Morgan McGuire), but it has its benefits: lighting-fast iteration times, lots of open-source third-party libraries, some nice language features like functions as first-class objects and JSON serialization, and some <a href="http://www.realtimerendering.com/blog/webgl-debugging-and-profiling-tools/" target="_blank">decent tools</a>.  Most people will be more productive in JavaScript than in C++.
</p>
<p>
JavaScript is not as fast as C++, which could be a concern if you are comparing a CPU-bound algorithm to previous work in C++.  For GPU-bound work, JavaScript and C++ are very similar.
</p>
<p>
TODO: better ending
</p>

</body>
</html>