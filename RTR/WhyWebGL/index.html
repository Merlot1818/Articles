<html>
<head>
</head>
<body>
<h1>Why use WebGL for Graphics Research?</h1>
<p>
By Patrick Cozzi, <a href="https://twitter.com/pjcozzi" target="_blank">@pjcozzi</a>.
</p>

<p>
This isn't as crazy as it sounds: WebGL has a chance to become the graphics API of choice for real-time graphics research.  Here's why I think so.
</p>

<p>
<strong>An interactive demo is better than a video</strong>.
</p>
<p>
WebGL allows us to embed demos in a website, like the <a href="http://jcgt.org/published/0001/01/02/webdemo/index.html" target="_blank">demo</a> for <a href="http://jcgt.org/published/0001/01/02/" target="_blank">The Compact YCoCg Frame Buffer</a> by Pavlos Mavridis and Georgios Papaioannou.  A demo gives readers a better understanding than a video alone, allows them to reproduce performance results on their hardware, and enables them to experiment with debug views like the <a href="http://sijietian.com/WebGL/deferredshading/index.html" target="_blank">demo</a> for <a href="https://hacks.mozilla.org/2014/01/webgl-deferred-shading/" target="_blank">WebGL Deferred Shading</a> by Sijie Tian, Yuqin Shao, and I.  This is, of course, true for a demo written with any graphics API, but WebGL makes the barrier-to-entry very low; it runs almost everywhere (iOS is still holding back the floodgates) and only requires clicking on a link.  Readers and reviewers are much more likely to check it out.
</p>

<p>
<strong>WebGL runs on desktop and mobile</strong>.
</p>
<p>
Android devices now have pretty good support for WebGL.  This allows us to write the majority of our demo once and get performance numbers for both desktop and mobile.  This is especially useful for algorithms that will have different performance implications due to differences in GPU architectures, e.g., early-z vs. tile-based, or network bandwidth, e.g., streaming massive models.
</p>

<p>
<strong>WebGL is starting to expose modern GPU features</strong>.
</p>
<p>
WebGL is based on OpenGL ES 2.0 so it doesn't expose features like query timers, compute shaders, uniform buffers, etc.  However, with some <a href="https://wiki.mozilla.org/Platform/GFX/WebGL2" target="_blank">WebGL 2</a> (based on ES 3.0) features being exposed as extensions, we are getting access to more GPU features like instancing and multiple render targets.  Given that OpenGL ES 3.1 will be <a href="https://www.khronos.org/assets/uploads/developers/library/2014-gdc/Khronos-OpenGL-ES-GDC-Mar14.pdf" target="_blank">released this year</a> with compute shaders, atomics, and image load/store, we can expect WebGL to follow.  This will allow compute-shader-based research in WebGL, an area where I expect we'll continue to see innovation.  In addition, with NVIDIA Tegra K1, we see <a href="http://www.nvidia.com/content/PDF/tegra_white_papers/Tegra_K1_whitepaper_v1.0.pdf" target="_blank">OpenGL 4.4 support on mobile</a>, which could ultimately mean more features exposed by WebGL to keep pace with mobile.
</p>
<p>
Some graphics research areas, like animation, don't always need access to the latest GPU features and instead just need a way to visualization their results.  Even many of the latest <a href="http://jcgt.org/read.html?reload=1" target="_blank">JCGT</a> papers on rendering can be implemented with WebGL and the extensions it exposes today.  On the other hand, some research will explore the latest GPU features or use features only available to languages with pointers, for example, using persistent-mapped buffers in <a href="http://www.slideshare.net/CassEveritt/approaching-zero-driver-overhead" target="_blank">Approaching Zero Driver Overhead</a> by Cass Everitt, Graham Sellers, John McDonald, and Tim Foley.
</p>

<p>
<strong>WebGL is faster to develop with</strong>.
</p>
<p>
Coming from C++, JavaScript takes some getting use to (see <a href="http://casual-effects.blogspot.com/2014/01/an-introduction-to-javascript-for.html" target="_blank">An Introduction to JavaScript for Sophisticated Programmers</a> by Morgan McGuire), but it has its benefits: lighting-fast iteration times, lots of open-source third-party libraries, some nice language features like functions as first-class objects and JSON serialization, and some <a href="http://www.realtimerendering.com/blog/webgl-debugging-and-profiling-tools/" target="_blank">decent tools</a>.  Most people will be more productive in JavaScript than in C++ once up to speed.
</p>
<p>
JavaScript is not as fast as C++, which is a concern when we are comparing a CPU-bound algorithm to previous work in C++.  However, for GPU-bound work, JavaScript and C++ are very similar.
</p>
<p>
<strong>Try it</strong>.
</p>
<p>
Check out the <a href="http://webglreport.com/" target="_blank">WebGL Report</a> to see what extensions your browser supports.  If it meets the needs for your next research project, give it a try!
</p>

</body>
</html>